UserRole.includes(:login_informations).for_provider_with_ancestors(provider)
UserRole.includes(:login_informations).for_provider_with_ancestors(provider).class
UserRole.includes(:login_informations).for_provider_with_ancestors(provider).order("LOWER(name)")
exit
item
local_assigns
exit
render_to_string partial: '/utilities/lists/multicolumn_list_item'
@item
render_to_string partial: '/utilities/lists/multicolumn_list_item'
item
local_assigns
exit
render_ partial: '/utilities/lists/multicolumn_list_item'
render_to_string partial: '/utilities/lists/multicolumn_list_item', locales: { item: @item, columns: [:name] }
item
local_assigns
column
exit
exit; exit
exit
exit; exit
domain
exit
quit
params
exit
@location
step
quit-all
quit
@item
step
quit
self.company.name
quit
test
step
test
step
test
quit-all
quit
test
quit
test
self.company.name
step
step 5
back
backtrace
up
iquit
quit
test
self.company.name
divison
division
division.blank
division.blank?
quit
quit -all
exit
quit
quit all
quit -all
quit --all
exit
stylesheets
exit
other_tools
exigt
quit
other_tools
quit
rfi
rfi.class
rfi_thread
rfi_thread.rfi
rfi.threads
rfi.rfi_threads
rfi.rfi_log_rfi_threads
rfi.rfi_threads
envelope
mail
RfiMailer
RfiMailer.new_rfi
RfiMailer.new_rfi(envelope)
RfiMailer.new_rfi(envelope, nil, nil)
GenericProcoreMailer
GenericProcoreMailer.new
GenericProcoreMailer.generate_email
GenericProcoreMailer.generate_email(envelope, nil)
exit
quit
deliverable?
self
whereami
@mailmessage.deliver
@mail_message.deliver
deliverable?
n
e
Exception
n
e
exit
ProcoreEmail.rfi_new(RfiLog::Rfi.last.id, LoginInformation.last.id)
exit
ProcoreEmail.rfi_new(RfiLog::Rfi.last.id, LoginInformation.last.id)
quit
ProcoreEmail.rfi_new(RfiLog::Rfi.last.id, LoginInformation.last.id)
ProcoreEmail.rfi_new_single_email(RfiLog::Rfi.last.id, 
  quit
ProcoreEmail.rfi_reply(RfiLog::Rfi.last.id, LoginInformation.last.id)
ProcoreEmail.rfi_reply_single_email(RfiLog::Rfi.last.id, LoginInformation.last.id)
ProcoreEmail.rfi_reply_single_email(RfiLog::Rfi.last.id, LoginInformation.first.id, LoginInformation.last.id)
RfiLog::Rfi.last
.project
RfiLog::Rfi.last.project
email = ProcoreEmail.rfi_reply_single_email(RfiLog::Rfi.last.id, LoginInformation.first.id, LoginInformation.last.id)
email.deliver
email.to = 'patrick@procore.com'
email.deliver
email.deliver!
ProcoreEmail.rfi_accepted(RfiLog::Rfi.last.id, RfiLog::RfiThread.last.id, LoginInformation.last.id)
ProcoreEmail.rfi_reopen(RfiLog::Rfi.last.id, LoginInformation.last.id)
ProcoreEmail.rfi_due_date_changed(RfiLog::Rfi)
ProcoreEmail.all_rfi_overdue_digest_emails
ProcoreEmail.rfi_due_date_changed(RfiLog::Rfi)
ProcoreEmail.rfi_due_date_changed(RfiLog::Rfi.last.id)
ProcoreEmail.rfi_reassigned(RfiLog::Rfi.last.id)
ProcoreEmail.rfi_question(RfiLog::Rfi.last.id, RfiLog::RfiThread.last.id, LoginInformation.last.id)
ProcoreEmail.overdue_rfi_digest(Company.last.id, Assigned.last.id)
ProcoreEmail.overdue_rfi_digest(Company.last.id, LoginInformation.last.id)
ProcoreEmail.overdue_rfi_digest(Company.last, LoginInformation.last.id)
Company.last
Assigned.last
ProcoreEmail.overdue_rfi_digest(Company.last, Company.Assinged.last.id)
ProcoreEmail.overdue_rfi_digest(Company.last, Assignee.last.id)
ProcoreEmail.overdue_rfi_digest(Company.last, Assignee.last)
ProcoreEmail.overdue_rfi_digest(Company.last, RfiLog::Assigned.last)
ProcoreEmail.overdue_rfi_digest(Company.last, RfiLog::Assigned.last.id)
ProcoreEmail.overdue_rfi_digest(Company.last, RfiLog::Assignee.last.id)
ProcoreEmail.overdue_rfi_digest(Company.last, RfiLog::Rfi.Assignee.last.id)
ProcoreEmail.overdue_rfi_digest(Company.last, RfiLog::Rfi.Assigned.last.id)
ProcoreEmail.overdue_rfi_digest(Company.last, LoginInformation.last.id)
ProcoreEmail.overdue_rfi_digest(Company.last, LoginInformation.last)
ProcoreEmail.overdue_rfi_digest(Company.last, LoginInformation.last).deliver
email = ProcoreEmail.overdue_rfi_digest(Company.last, LoginInformation.last)
email
email.to =  "patrick@procore.com"
email.deliver
quir
exit
n
templay_type
tmp
n
templay_type
n
templay_type
n
nn
n
nn
n
nn
n
nn
n
nn
n
quit
rfis
RfiLog::Item
RfiLog::Item.all
RfiLog::Thread
RfiLog::Thread.all
exit
play -l 326
@questionm
@question.valid?
@question.erros
@question.errors
params
exit
n
nn
n
eixt
exit
icon
office.logo
company
office
icon
project?
icon
office.logo
quir
quit
exit
n
company.pdf_logo_url
quit
exit
thumbnail
quit
thumbnail
company
url_for_immediate_use(company)
n
nn
n
nn
n
exit
exit all
exit
template_type
holder
domain_id
model_name
associated_with
item_log
exit
holder.project? && (parent_holder = holder.company
  q
  quit
(holder.project? && (parent_holder = holder.company))
(associated_with.nil? && domain_id.nil? && !all_templates.first.blank?)
all_templates
n
all_templates
quit
exit
question
question.id
enable_inplace_edit
question.due_date
'due_date'
exit
exit all
quite
quit
exit
exit all
object
field
value
options
exit
quit
n
exit
exit program
exit -program
exit-program
klass
id
field
original_value
new_value
whereami
n
object
new_value
n
status
n
status
n
new_value
n
nn
n
nn
n
nn
n
exit-progoram
exitprogram
exit
current_page
current_path
current_page?
current_page?(project_admin_tab_path)
project_admin_equipment_tab_path(@project)
current_page?
current_page?(project_admin_equipment_tab_path(@project))
exit
n
quit
exit
n
nn
n
association(name).reader(*params)
exit
n
uit
quit
creator = FactoryGirl.create(:login_information, :login => "creator@foo.com")
@creator = FactoryGirl.create(:login_information, :login => "creator@foo.com")
@creator = FactoryGirl.create(:login_information, {:login => "creator@foo.com"})
exit
@creator = FactoryGirl.create(:login_information, {:login => "creator@foo.com"})
@creator = FactoryGirl.create(:login_information, {:login => "blah@foo.com"})
@creator = FactoryGirl.create(:login_information)
@creator.login = creator@foo.com
@creator.login = "creator@foo.com"
@creator.login
exit
play -l 45
@creator = FactoryGirl.create(:login_information)
@creator.login = "login@foo.com"
exit
@header
play n
n
@header
play -l 23-25
play -l 23-26
whereami
exit
@header
@header.all
@header.methods
@header
@header.company_auto_complete
@header.company
@header.provider
@provider
@provider.company_auto_complete
@provider.company_autocomplete
quit
@header
exit
@header
:subtab
subtab = #{params[:subtab]}
xe
subtab = params[:subtab]
subtab_list
@header = @project.rfis.find(params[:id])
subtab_list =
[{selected: true,
    label: I18n.t("views.global.general"),
    disabled: true,
    href: {action: "create",
      controller: "headers",
      id: @header.id,
    subtab: :item }
}]
subtab_list
quir
quit
@header
@header = @project.rfis.find(params[:id])
quit
@project.rfis
@project.rfis.find(params[:id]}
@project.rfis.find(params[:id])
quit
params
@header
exit
quit
@recipient.locale.presence
@project.locale.presence
@company.locale.presence
I18n.locale
quit
c
filename
wuit
quit
xml_string
rfis
rfis = questions(false)
exit
rfis
rfis = questions(false)
play -l 118
exit
pdf_url
xml_string
quit
row
r
r.received_from_login_information_id.name
r.received_from_login_information_id
r.received_from_login_information_id:name
r.received_from_login_information_id.name
r.received_from_login_information_id.last_first_with_company
r.received_from_login_information_id
r
s
r.last_first_with_company
exit
r
r.formatted_ball_in_court_without_company
r.received_from_login_information_id.try(:name, :last_first_with_company, @company.id) || ""
r.formatted_latest_assignee_response_date
r.time_resolved
r.accepted
r.cost_code
r.custom_textfield_1
r.custom_textfield_2
r.schedule_impact_text
r.cost_impact_text
quit
exit
r
r.received_from_login_information
quit
(r.received_from_login_information.try(:name, :last_first_with_company, @company.id) || "")
quit
exit
headers_path
create_communication_header_path
path = create_communication_headers_path
path = create_communication_header_path(header)
path = create_communication_header_path(@header)
path = headers_path, method: :post
path = (headers_path, method: :post)
path = (headers_path, method= :post)
path = (headers_path, method= post)
quit
@header
@project.rfis.find(params[:id])
@header = @project.rfis.find(params[:id])
@header = @project.rfis.find(params[new])
@header = @project.rfis.find(params[:header])
quit
exit
:header
@header
@header.find(params[:id])
quit
@header
quit
@header
quit
@RESPONSE
@response
@response.save
exit
quit
header
exit
header.id
header
exti
exit
quit
@header
@header.new_record?
exit
related_to_table(@header, false, false, false, false)
quit
@header.show_related_communications
header.show_related_communications
show_related_communications
:show_related_communications
exit
header
@header
@header.communication
@header.communications
@header.all
@header.methods
@header.methods | grep email
@header.methods
exit
header.methods | grep "changes"
header.methods | grep change
header.methods
header
@header.methods | grep change
@header.methods | grep "change"
@header.methods 
@header.changed_attributes
@header.previous_changes
@header.previous_changed
@header.changed
@header.changed?
quit
@header
@header.updated
@header.updated?
@header.updated
@header.methods
@header.distribution
@header.distribution.methods
@header.question
@header.question.methods
@header.methods
@headers.skip_emails
@header.methods
@headers.changed_attributes
@headers.changes
@headers.changed
@headers.changed?
@headers.previous_changes
@header
@header.communication_topic
@header.id.methods
@header.emails
@header.prostore_files
@header.prostore_file
@header.prostore
@header.distribution
@header.distribution.methods
@header.attributes
@header.communication
@header.communications
@header.methods.all
@heade.all
@header.all
@header.methods
@header.subject_changed
@header.subject_changed?
@header.subject_change
@header.history
@header.change_history
@header.methods
exit
@header.methods
@header.active_histories
@header.active_histories=
exit
@header
@header.communications
@header.active_histories
@header.methods
@header.attachments
@header.id.methods
@header.related_to
@header.historyable?
@header.ah_record_change
@header.active_history_item_short_description
@header.active_history_item_long_description
@header.ah_record_change
@header.ah_record_change(@user)
@header.ah_parents
@header.ProstoreFile
@header.ActiveHistory
@header.communication
@header.id.communication
@headers
@header.question
@header.question.methods
quit
@headers.related_items.methods
@email
@header.inbound
@header.inbound_email
@header.inbound_email?
@header.inbound_emails
@header.inbound_records
@header.email_exists?
@inbound_emails
@inbound_emails.methods
@header.email_exists?
@change_history
@change_history.count
@changes.count
@changed_attributes
quit
email
@header.email
@email
@email.methods
@email.acts_like>
q
@email.acts_like?
@header.methods do
  grep communication
end
@header.email.collect
@email.collect
@communications
@header.related_to
@change_history
@header.methods
exit
@header
@header.changes
@header.change
@header.changed
@header.changed?
h = Header.new
h = Rfi::Header.new
h.changes
h.accepted = true
h.changes
quit
subtab_hash
subtab_info
quit
subtab_info
view_context
view.context
h
h.view_context
ls h
l h
@header
quit'
quit
@header
@header.active_histories
@header.active_histories.count
@header.active_histories.all
quit
